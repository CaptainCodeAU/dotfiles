# Smart Session Management

# Attach to session or create if it doesn't exist
ta='tmux attach -t "$1" 2>/dev/null || tmux new-session -s "$1"'

# Attach to session or create if it doesn't exist
alias ts='tmux attach -t "$1" 2>/dev/null || tmux new-session -s "$1"'

# Kill all tmux sessions (nuclear option)
alias tkill='tmux kill-server'

# Quick attach to most recent session
alias tlast='tmux attach'

# List sessions with more detail
alias tls='tmux list-sessions -F "#{session_name}: #{session_windows} windows (created #{session_created_string}) #{?session_attached,(attached),}"'

# Coding-Specific Aliases
alias ideas='cd ~/CODE/Ideas'

# Create tmux session for specific project
alias tcode='cd ~/CODE/Ideas/"$1" && tmux new-session -s "$1" -c "$(pwd)"'

# Quick tmux session in current directory
alias there='tmux new-session -s "$(basename $(pwd))" -c "$(pwd)"'

# List code projects and create tmux session
alias tpick='cd ~/CODE/Ideas && ls -1 | fzf --preview "ls -la ~/CODE/Ideas/{}" | xargs -I {} bash -c "cd ~/CODE/Ideas/{} && tmux new-session -s {} -c $(pwd)"'

# Show pretty git log
alias glog='git log --graph --pretty=format:"%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset" --abbrev-commit'


# List projects and pick one to work on
pickp() {
    cd ~/CODE/Ideas
    local project=$(ls -1 | fzf --preview "ls -la ~/CODE/Ideas/{}")
    if [ -n "$project" ]; then
        workp "$project"
    fi
}

# Switch branch and update tmux window name
gswitch() {
    git switch "$1"
    tmux rename-window "$(basename $(pwd)):$1" 2>/dev/null || true
}

# Enhanced git switch that also updates tmux window name
gswtmux() {
    git switch "$1" && tmux rename-window "$(basename $(pwd)):$1" 2>/dev/null || true
}

# Create new branch and switch (enhances your existing gswc)
gswctmux() {
    git switch --create "$1" && tmux rename-window "$(basename $(pwd)):$1" 2>/dev/null || true
}

# Function that runs after any git switch/checkout
update_tmux_branch() {
    if [ -n "$TMUX" ]; then
        local current_branch=$(git branch --show-current 2>/dev/null)
        if [ -n "$current_branch" ]; then
            tmux rename-window "$(basename $(pwd)):$current_branch" 2>/dev/null || true
        fi
    fi
}

# Wrapper for git switch that auto-updates tmux
gs_auto() {
    git switch "$@" && update_tmux_branch
}

# Tmux-aware git switch (doesn't conflict with existing gsw)
gt() {
    git switch "$1" && tmux rename-window "$(basename $(pwd)):$1" 2>/dev/null || true
}

# Tmux-aware branch creation
gtc() {
    git switch --create "$1" && tmux rename-window "$(basename $(pwd)):$1" 2>/dev/null || true
}


# Create feature branch following git flow
gfeature() {
    local branch_name="feature/$1"
    git checkout -b "$branch_name"
    git push -u origin "$branch_name"
    tmux rename-window "$(basename $(pwd)):$branch_name" 2>/dev/null || true
}

# Quick PR workflow
gpr_quick() {
    git add --all
    git commit -m "$1"
    git push origin $(git branch --show-current)
    echo "Ready for PR: $(git branch --show-current)"
}

# Compact version for quick checks
gs() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "‚ùå Not a git repo"
        return 1
    fi

    local branch=$(git branch --show-current)
    local status_count=$(git status --porcelain | wc -l | tr -d ' ')
    local repo=$(basename $(git rev-parse --show-toplevel))

    echo "üìÅ $repo üåø $branch"

    if [ "$status_count" -gt 0 ]; then
        echo "üìù $status_count changes:"
        git status --short | head -5
    else
        echo "‚úÖ Clean working directory"
    fi

    # Show last commit
    echo "üìö $(git log -1 --oneline)"
}

# Create coding session with multiple windows
tdev() {
    local project="$1"
    local session_name="dev-$project"

    cd "~/CODE/Ideas/$project"

    # Create session with main coding window
    tmux new-session -d -s "$session_name" -c "$(pwd)" -n "code"
    tmux send-keys -t "$session_name:code" "claude-code ." Enter

    # Add git window
    tmux new-window -t "$session_name" -n "git" -c "$(pwd)"
    tmux send-keys -t "$session_name:git" "git status" Enter

    # Add terminal window for running commands
    tmux new-window -t "$session_name" -n "term" -c "$(pwd)"

    # Add logs/monitoring window
    tmux new-window -t "$session_name" -n "logs" -c "$(pwd)"

    # Go back to code window and attach
    tmux select-window -t "$session_name:code"
    tmux attach-session -t "$session_name"
}

# Show status of all projects
codestatus() {
    echo "=== CODE PROJECTS STATUS ==="
    cd ~/CODE/Ideas
    for project in */; do
        if [ -d "$project/.git" ]; then
            echo "üìÅ $project"
            cd "$project"
            echo "   Branch: $(git branch --show-current)"
            echo "   Status: $(git status --porcelain | wc -l) changes"
            echo "   Last commit: $(git log -1 --pretty=format:'%cr - %s')"
            echo ""
            cd ..
        fi
    done
}




# ==============================================================================
#  TMUX FUNCTIONS
# ==============================================================================

# 1. ta <session-name> - attach to session or create if doesn't exist
ta() {
    if [ -z "$1" ]; then
        echo "Usage: ta <session-name>"
        return 1
    fi
    tmux attach -t "$1" 2>/dev/null || tmux new-session -s "$1"
}

# 2. tc - attach to 'coding' session (create if doesn't exist)
tc() {
    tmux attach -t "coding" 2>/dev/null || tmux new-session -s "coding"
}

# 3. tcc - attach to 'claudecode' session (create if doesn't exist)
tcc() {
    tmux attach -t "claudecode" 2>/dev/null || tmux new-session -s "claudecode"
}

# ==============================================================================
#  GIT STATUS DASHBOARD FUNCTIONS
# ==============================================================================

# Main git overview function - shows everything you need to know
gstatus() {
    # Check if we're in a git repo
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "‚ùå Not in a git repository"
        return 1
    fi

    local repo_name=$(basename $(git rev-parse --show-toplevel))
    local current_branch=$(git branch --show-current)
    local repo_root=$(git rev-parse --show-toplevel)

    echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
    echo "‚îÇ                    üìÅ GIT REPOSITORY STATUS                     ‚îÇ"
    echo "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§"
    echo "‚îÇ Repository: $repo_name"
    echo "‚îÇ Location:   $repo_root"
    echo "‚îÇ Branch:     üåø $current_branch"
    echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
    echo ""

    # Remote information
    echo "üåê REMOTE INFORMATION"
    echo "‚îú‚îÄ Origin URL: $(git remote get-url origin 2>/dev/null || echo 'No remote configured')"
    if git remote show origin >/dev/null 2>&1; then
        local remote_branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "No upstream")
        echo "‚îú‚îÄ Upstream:   $remote_branch"

        # Check if we can fetch from remote
        echo "‚îú‚îÄ Remote Status:"
        if timeout 5 git fetch --dry-run >/dev/null 2>&1; then
            local ahead=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")
            local behind=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")

            if [ "$ahead" -gt 0 ]; then
                echo "‚îÇ  ‚îî‚îÄ ‚¨áÔ∏è  $ahead commits behind remote"
            fi
            if [ "$behind" -gt 0 ]; then
                echo "‚îÇ  ‚îî‚îÄ ‚¨ÜÔ∏è  $behind commits ahead of remote"
            fi
            if [ "$ahead" -eq 0 ] && [ "$behind" -eq 0 ]; then
                echo "‚îÇ  ‚îî‚îÄ ‚úÖ In sync with remote"
            fi
        else
            echo "‚îÇ  ‚îî‚îÄ ‚ö†Ô∏è  Cannot reach remote (offline?)"
        fi
    fi
    echo ""

    # Branch information
    echo "üåø BRANCH INFORMATION"
    echo "‚îú‚îÄ Local branches:"
    git branch --format="‚îÇ  ‚îú‚îÄ %(if)%(HEAD)%(then)üü¢ %(refname:short) (current)%(else)   %(refname:short)%(end)" | head -10

    echo "‚îú‚îÄ Recent remote branches:"
    git branch -r --sort=-committerdate --format="‚îÇ  ‚îú‚îÄ üì° %(refname:short)" | head -5
    echo ""

    # Working directory status
    echo "üìù WORKING DIRECTORY"
    if [ -n "$(git status --porcelain)" ]; then
        echo "‚îú‚îÄ Changes detected:"
        git status --porcelain | while read status file; do
            case $status in
                "M ") echo "‚îÇ  ‚îú‚îÄ üìù Modified:   $file" ;;
                " M") echo "‚îÇ  ‚îú‚îÄ üîÑ Modified:   $file (unstaged)" ;;
                "A ") echo "‚îÇ  ‚îú‚îÄ ‚ûï Added:      $file" ;;
                "D ") echo "‚îÇ  ‚îú‚îÄ ‚ùå Deleted:    $file" ;;
                "??") echo "‚îÇ  ‚îú‚îÄ ‚ùì Untracked:  $file" ;;
                *) echo "‚îÇ  ‚îú‚îÄ $status $file" ;;
            esac
        done
        echo "‚îÇ"
        echo "‚îú‚îÄ Quick actions:"
        echo "‚îÇ  ‚îú‚îÄ 'gaa' - add all changes"
        echo "‚îÇ  ‚îú‚îÄ 'gc \"message\"' - commit with message"
        echo "‚îÇ  ‚îî‚îÄ 'gp' - push to remote"
    else
        echo "‚îú‚îÄ ‚úÖ Working directory clean"
    fi
    echo ""

    # Recent commit history
    echo "üìö RECENT COMMITS"
    git log --oneline --graph --decorate --color=always -8 | sed 's/^/‚îú‚îÄ /'
    echo ""

    # Stash information
    local stash_count=$(git stash list | wc -l | tr -d ' ')
    if [ "$stash_count" -gt 0 ]; then
        echo "üíæ STASHED CHANGES ($stash_count)"
        git stash list --format="‚îú‚îÄ %gd: %gs" | head -3
        echo ""
    fi
}

# Compact version for quick checks
gs() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "‚ùå Not a git repo"
        return 1
    fi

    local branch=$(git branch --show-current)
    local status_count=$(git status --porcelain | wc -l | tr -d ' ')
    local repo=$(basename $(git rev-parse --show-toplevel))

    echo "üìÅ $repo üåø $branch"

    if [ "$status_count" -gt 0 ]; then
        echo "üìù $status_count changes:"
        git status --short | head -5
    else
        echo "‚úÖ Clean working directory"
    fi

    # Show last commit
    echo "üìö $(git log -1 --oneline)"
}

# Show git tree (requires installation)
gtree() {
    if command -v git-tree >/dev/null 2>&1; then
        git-tree
    elif command -v tig >/dev/null 2>&1; then
        tig
    else
        echo "üå≥ GIT TREE (install 'git-tree' or 'tig' for better visualization)"
        git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit -10
    fi
}

# Show what you're working on (files you've recently modified)
gwip2() {
    echo "üî® WHAT YOU'RE WORKING ON"
    echo "‚îú‚îÄ Recently modified files:"

    # Show files modified in the last 24 hours
    find . -name ".git" -prune -o -type f -newermt "1 day ago" -print | head -10 | while read file; do
        echo "‚îÇ  ‚îú‚îÄ üìù $file"
    done

    echo "‚îú‚îÄ Staged changes:"
    if [ -n "$(git diff --cached --name-only)" ]; then
        git diff --cached --name-only | while read file; do
            echo "‚îÇ  ‚îú‚îÄ ‚úÖ $file"
        done
    else
        echo "‚îÇ  ‚îî‚îÄ No staged changes"
    fi

    echo "‚îú‚îÄ Unstaged changes:"
    if [ -n "$(git diff --name-only)" ]; then
        git diff --name-only | while read file; do
            echo "‚îÇ  ‚îú‚îÄ üîÑ $file"
        done
    else
        echo "‚îÇ  ‚îî‚îÄ No unstaged changes"
    fi
}

# ==============================================================================
#  BONUS: RECOMMENDED CLI TOOLS TO INSTALL
# ==============================================================================

# Installation commands (run these once):
# brew install git-tree          # Beautiful git tree visualization
# brew install tig               # Text-mode interface for Git
# brew install lazygit           # Terminal UI for git commands
# brew install git-delta         # Better git diff viewer
# brew install gh                # GitHub CLI

# Lazy git launcher
lg() {
    if command -v lazygit >/dev/null 2>&1; then
        lazygit
    else
        echo "Install lazygit for an amazing terminal git UI: brew install lazygit"
    fi
}

# ==============================================================================
#  USAGE EXAMPLES
# ==============================================================================

# echo "üí° USAGE EXAMPLES:"
# echo "ta mysession    - attach/create tmux session 'mysession'"
# echo "tc             - attach/create tmux session 'coding'"
# echo "tcc            - attach/create tmux session 'claudecode'"
# echo "gstatus        - full git repository dashboard"
# echo "gs             - quick git status"
# echo "gtree          - visual git tree"
# echo "gwip           - show what you're working on"
# echo "lg             - launch lazygit (if installed)"


# Function: Create a git-aware coding session in Ideas subfolder
# - Creates session named after project
# - CDs to ~/CODE/Ideas/project (creates dir if missing)
# - If not a git repo, prompts to init or clone
# - Splits into panes: one for editing, one for git status/log
tgit() {
    local proj="${1:-newproj}"
    local dir=~/CODE/Ideas/"$proj"
    mkdir -p "$dir"
    cd "$dir" || return
    if [ ! -d .git ]; then
        read -p "Init git repo here? (y/n/clone URL): " choice
        case "$choice" in
            y) git init ;;
            http* | git*) git clone "$choice" . ;;
        esac
    fi
    tmux new-session -d -s "$proj" -c "$dir"
    tmux split-window -h -t "$proj"  # Horizontal split
    tmux send-keys -t "$proj:0.0" 'git status' C-m  # Git status in left pane
    tmux send-keys -t "$proj:0.1" 'vim' C-m  # Editor in right pane (replace 'vim' with 'claude' if it's a command)
    tmux new-window -t "$proj" -n logs
    tmux send-keys -t "$proj:1" 'git log --oneline --graph' C-m
    tmux attach-session -t "$proj"
}
# Usage: tgit myproject (sets up git session; prompts if no repo)

# Function: Quick git branch session
# - Starts in project dir
# - Panes for branch list, checkout, and main work
tbranch() {
    local proj="$1"
    local dir=~/CODE/Ideas/"$proj"
    if [ ! -d "$dir" ]; then echo "Project dir not found"; return; fi
    tmux new-session -d -s "${proj}-branch" -c "$dir"
    tmux split-window -v -t "${proj}-branch"  # Vertical split
    tmux send-keys -t "${proj}-branch:0.0" 'git branch -a' C-m  # Branch list top
    tmux send-keys -t "${proj}-branch:0.1" 'echo "Run git checkout here"' C-m  # Bottom for commands
    tmux attach-session -t "${proj}-branch"
}
# Usage: tbranch myproject (for branching workflows)

# Function: Git pull/merge session
# - For pulling changes and resolving merges
# - Includes a pane for git diff
tpull() {
    local proj="$1"
    local dir=~/CODE/Ideas/"$proj"
    if [ ! -d "$dir/.git" ]; then echo "Not a git repo"; return; fi
    tmux new-session -d -s "${proj}-pull" -c "$dir"
    tmux split-window -h -t "${proj}-pull"
    tmux send-keys -t "${proj}-pull:0.0" 'git pull' C-m
    tmux send-keys -t "${proj}-pull:0.1" 'git diff' C-m
    tmux attach-session -t "${proj}-pull"
}
# Usage: tpull myproject (for pull/merge workflows)

# Function: Clean up old code sessions
# - Kills sessions matching "code" or project names
tclean() {
    tmux list-sessions | grep -E 'code|proj|git|branch|pull' | cut -d: -f1 | xargs -I {} tmux kill-session -t {}
}
# Usage: tclean (kills all coding-related sessions)

# Show global options
alias tshow='tmux show-options -g'
